# 组织管理员权限审计报告

**审计日期**: 2026-02-11  
**审计范围**: 组织管理员访问"人员和组织管理"功能的权限控制链路  
**问题现象**: 组织管理员访问 `/api/v1/org-tree` 返回 `403 Forbidden: super admin privileges required`

---

## 1. 当前架构概览

### 1.1 权限模型

系统采用两级权限模型：
- **超级管理员 (Super Admin)**: 拥有所有操作权限，可管理全部组织树
- **组织管理员 (Org Admin)**: 应仅能管理自己担任管理员的组织及其子树

### 1.2 请求链路

```
前端页面 → 前端路由守卫 → API请求 → 后端路由中间件 → Handler → Service → Repository
```

---

## 2. 问题根因分析

### 2.1 【关键问题】路由中间件层——所有 org-tree 路由被 RequireSuperAdmin 中间件阻断

**文件**: `internal/router/router.go` 第120-134行

```go
// Super admin routes (require super admin privileges)
superAdmin := v1.Group("", middleware.RequireSuperAdmin())
{
    RegisterOrgTreeRoutes(superAdmin, params.OrgTreeHandler)  // ← 所有 org-tree 路由都在超管组下
    RegisterModelWriteRoutes(superAdmin, params.ModelHandler)
    RegisterSystemRoutes(superAdmin, params.SystemHandler)
}
```

**问题**: `RegisterOrgTreeRoutes` 注册的全部15个路由都位于 `RequireSuperAdmin()` 中间件保护的路由组下。这意味着任何非超管用户（包括组织管理员）访问这些路由时，请求在到达 Handler 之前就被中间件拦截返回 403。

**中间件代码** (`internal/middleware/super_admin.go`):

```go
func RequireSuperAdmin() gin.HandlerFunc {
    return func(c *gin.Context) {
        // ...
        if !user.IsSuperAdmin {
            c.JSON(http.StatusForbidden, gin.H{
                "error": "Forbidden: super admin privileges required",  // ← 日志中看到的错误
            })
            c.Abort()
            return
        }
        c.Next()
    }
}
```

### 2.2 Handler层——权限检查逻辑正确但无法被触达

**文件**: `internal/handler/org_tree.go`

以下 Handler 函数中包含了对组织管理员的权限检查逻辑（`if !user.IsSuperAdmin { ... 检查是否是组织admin ... }`），**但由于路由中间件已先行拦截，这些代码永远不会被非超管用户执行**：

| Handler 函数 | 行号 | 组织管理员权限检查 |
|---|---|---|
| `CreateOrgNode` | 75-130 | ✅ 有（不允许创建根节点，需是父组织admin） |
| `AssignUser` | 280-336 | ✅ 有（需是目标组织admin） |
| `CreateUserInOrg` | 350-430 | ✅ 有（需是目标组织admin） |
| `RemoveUser` | 535-600 | ✅ 有（需是目标组织admin） |
| `SetOrgAdmin` | 620-695 | ✅ 有（需是目标组织admin） |
| `GetOrgTree` | 46-60 | ❌ 无（直接调用 `GetTree` 返回完整树） |
| `UpdateOrgNode` | 168-200 | ❌ 无（直接更新，无权限检查） |
| `DeleteOrgNode` | 210-226 | ❌ 无（直接删除，无权限检查） |
| `MoveOrgNode` | 240-270 | ❌ 无（直接移动，无权限检查） |
| `ListOrgMembers` | 735-775 | ❌ 无（直接列出，无权限检查） |
| `SearchUsersForAssign` | 780-815 | ❌ 无（直接搜索，无权限检查） |
| `SetSuperAdmin` | 820-848 | ❌ 无（仅超管可操作，当前路由控制正确） |

### 2.3 Service层——已有 `GetTreeForUser` 方法但未被使用

**文件**: `internal/application/service/org_tree.go` 第237-300行

```go
func (s *orgTreeService) GetTreeForUser(ctx context.Context, userID string, tenantID uint64, isSuperAdmin bool) ([]*types.OrgTreeNode, error) {
    // 超管看完整树
    if isSuperAdmin {
        return s.GetTree(ctx, tenantID)
    }
    // 组织管理员只看自己管理的子树
    // ...提取 admin 组织的子树作为根节点返回
}
```

**问题**: `GetOrgTree` Handler 直接调用 `GetTree(ctx, tenantID)` 获取完整树，而不是调用已存在的 `GetTreeForUser` 方法。

### 2.4 Service层接口——缺少 `GetTreeForUser` 声明

**文件**: `internal/types/interfaces/org_tree.go`

`OrgTreeService` 接口中只声明了 `GetTree`，没有声明 `GetTreeForUser`。虽然 Service 实现中存在此方法，但 Handler 无法通过接口调用它。

### 2.5 前端层——路由守卫和UI控制基本正确

**文件**: `frontend/src/router/index.ts` 第101-114行

前端路由使用 `requiresOrgAdmin` meta 标记，路由守卫检查 `authStore.isSuperAdmin || authStore.isOrgAdmin`，逻辑正确。

**文件**: `frontend/src/views/admin/OrgTreeManage.vue`

- "创建根组织"按钮使用 `v-if="authStore.isSuperAdmin"` 控制 ✅
- 但页面加载时调用 `orgTreeStore.fetchTree()` → 调用 `getOrgTree()` API → 被后端中间件拦截 ❌

**文件**: `frontend/src/views/admin/components/OrgTreeNodeItem.vue`

- `canManageNode` 计算属性：`authStore.isSuperAdmin || props.node.my_is_admin === true` ✅
- 操作按钮根据权限显示/隐藏 ✅

---

## 3. 需要修复的问题清单

### 3.1 【P0-必须修复】路由层：将org-tree路由从超管组迁移出来

**文件**: `internal/router/router.go`

**修改方案**:
- 将需要组织管理员访问的路由从 `superAdmin` 组移到 `v1` 组（需认证但不要求超管）
- 新增 `RequireOrgAdmin()` 中间件，允许超管或组织管理员访问
- 保留 `SetSuperAdmin` 和 `SearchUsersForAssign` 在超管组中（仅超管可用）

**路由分组方案**:

| 路由 | 新分组 | 理由 |
|---|---|---|
| GET `/org-tree` | orgAdmin组 | 组织管理员需要获取自己可见的树 |
| POST `/org-tree` | orgAdmin组 | 组织管理员可创建子节点 |
| GET `/org-tree/:id` | orgAdmin组 | 组织管理员可查看节点 |
| PUT `/org-tree/:id` | orgAdmin组 | 组织管理员可编辑管理的节点 |
| DELETE `/org-tree/:id` | orgAdmin组 | 组织管理员可删除管理的叶子节点 |
| POST `/org-tree/:id/move` | orgAdmin组 | 组织管理员可移动管理的节点 |
| GET `/org-tree/:id/members` | orgAdmin组 | 组织管理员可查看成员 |
| POST `/org-tree/:id/members` | orgAdmin组 | 组织管理员可添加成员 |
| POST `/org-tree/:id/create-user` | orgAdmin组 | 组织管理员可创建用户 |
| PUT `/org-tree/:id/users/:user_id` | orgAdmin组 | 组织管理员可编辑用户 |
| DELETE `/org-tree/:id/members/:user_id` | orgAdmin组 | 组织管理员可移除成员 |
| PUT `/org-tree/:id/admin` | orgAdmin组 | 组织管理员可设置子管理员 |
| GET `/org-tree/search-users` | orgAdmin组 | 组织管理员需搜索用户以添加 |
| PUT `/org-tree/super-admin` | superAdmin组 | 仅超管可设置超管 |

### 3.2 【P0-必须修复】新增中间件：RequireOrgAdmin

**文件**: 新建 `internal/middleware/org_admin.go`

允许超管和组织管理员通过。组织管理员的判定方法：查询用户在当前租户的组织树中是否有任何 admin 角色的成员关系。

### 3.3 【P0-必须修复】Handler层：GetOrgTree 使用 GetTreeForUser

**文件**: `internal/handler/org_tree.go`

`GetOrgTree` Handler 应改为调用 `GetTreeForUser(ctx, userID, tenantID, isSuperAdmin)`，让组织管理员只看到自己管理的子树。

### 3.4 【P0-必须修复】接口层：添加 GetTreeForUser 声明

**文件**: `internal/types/interfaces/org_tree.go`

在 `OrgTreeService` 接口中添加 `GetTreeForUser` 方法签名。

### 3.5 【P1-应该修复】Handler层：UpdateOrgNode、DeleteOrgNode、MoveOrgNode 添加权限检查

这些 Handler 当前无权限检查。组织管理员应仅能操作自己管理的组织及其子节点。

**修改方案**: 检查操作目标节点是否在用户管理的组织子树内。

### 3.6 【P1-应该修复】Handler层：ListOrgMembers 添加权限检查

组织管理员应仅能查看自己管理的组织的成员。

### 3.7 【P1-应该修复】Handler层：CreateUserInOrg 修复 AssignRequest 中使用错误的用户ID

**文件**: `internal/handler/org_tree.go` 第420行

```go
assignReq := &types.AssignUserToOrgRequest{
    UserID: user.ID,    // ← BUG: 应该是 newUser.ID，这里用的是当前登录用户的ID
    Role:   types.OrgMemberRole(req.Role),
}
```

---

## 4. 修复方案详细设计

### 4.1 新增 RequireOrgAdmin 中间件

```go
// RequireOrgAdmin 允许超管或组织管理员通过
// 需要注入 OrgTreeService，或直接查询数据库判断用户是否是任何组织的admin
func RequireOrgAdmin(orgMemberRepo) gin.HandlerFunc {
    return func(c *gin.Context) {
        user := getUserFromContext(c)
        if user.IsSuperAdmin { c.Next(); return }
        // 查询用户在 tenant 中是否有 admin 角色的 org_members 记录
        hasAdminRole := orgMemberRepo.HasAdminRole(user.ID, tenantID)
        if !hasAdminRole { c.Abort(); return 403 }
        c.Next()
    }
}
```

### 4.2 路由重组

```go
// 需要组织管理员或超管的路由
orgAdminGroup := v1.Group("", middleware.RequireOrgAdmin(orgMemberRepo))
{
    RegisterOrgTreeRoutes(orgAdminGroup, params.OrgTreeHandler)
}

// 仅超管路由（SetSuperAdmin 单独注册）
superAdmin := v1.Group("", middleware.RequireSuperAdmin())
{
    superAdmin.PUT("/org-tree/super-admin", params.OrgTreeHandler.SetSuperAdmin)
    RegisterModelWriteRoutes(superAdmin, params.ModelHandler)
    RegisterSystemRoutes(superAdmin, params.SystemHandler)
}
```

### 4.3 Handler 中 GetOrgTree 修改

```go
func (h *OrgTreeHandler) GetOrgTree(c *gin.Context) {
    user := getUserFromContext(c)
    tree, err := h.orgTreeService.GetTreeForUser(ctx, user.ID, tenantID, user.IsSuperAdmin)
    // ...
}
```

### 4.4 各写操作 Handler 添加/完善权限检查

提取公共方法 `isUserOrgAdminOrAncestor(ctx, userID, orgID, tenantID) bool`，检查用户是否是指定组织或其祖先组织的管理员。

---

## 5. 修复优先级和影响范围

| 修改项 | 文件 | 优先级 | 状态 |
|---|---|---|---|
| 路由重组（移出SuperAdmin组） | `internal/router/router.go` | P0 | ✅ 已修复 |
| 接口添加 GetTreeForUser | `internal/types/interfaces/org_tree.go` | P0 | ✅ 已修复 |
| GetOrgTree 改用 GetTreeForUser | `internal/handler/org_tree.go` | P0 | ✅ 已修复 |
| Handler 添加 helper 方法（getUserFromContext, isOrgAdminOf, isOrgAdminOfAny） | `internal/handler/org_tree.go` | P0 | ✅ 已修复 |
| 所有13个 Handler 添加细粒度权限检查 | `internal/handler/org_tree.go` | P0 | ✅ 已修复 |
| copyNodeTree 传播 MyIsAdmin 到子树 | `internal/application/service/org_tree.go` | P1 | ✅ 已修复 |
| 修复 CreateUserInOrg 的 UserID bug | `internal/handler/org_tree.go` | P1 | ✅ 已修复 |
| 前端拖拽权限限制 | `frontend/src/views/admin/components/OrgTreeNodeItem.vue` | P1 | ✅ 已修复 |

---

## 6. 已实施修复详情

### 6.1 路由重组 (`internal/router/router.go`)

将 `RegisterOrgTreeRoutes` 从 `superAdmin` 路由组移至 `v1` 认证路由组（仅需登录），细粒度权限由 Handler 层控制。仅保留 `PUT /org-tree/super-admin` 在超管路由组中（`RegisterOrgTreeSuperAdminRoutes`）。

### 6.2 Handler 层重写 (`internal/handler/org_tree.go`)

新增三个通用 helper 方法：
- `getUserFromContext(c)` — 从 gin context 提取 `*types.User`
- `isOrgAdminOf(c, user, orgID, tenantID)` — 检查用户是否为超管或指定组织/祖先组织的管理员
- `isOrgAdminOfAny(c, user, tenantID)` — 检查用户是否为超管或任何组织的管理员

所有13个 Handler 函数均使用这些 helper 进行权限检查，遵循统一模式：
- 读操作（GetOrgTree/SearchUsers）：需要 `isOrgAdminOfAny`
- 写操作（Create/Update/Delete/Move/Assign/Remove 等）：需要 `isOrgAdminOf` 目标组织

### 6.3 Service 层修复 (`internal/application/service/org_tree.go`)

`copyNodeTree` 函数添加 `isAdminSubtree` 参数，组织管理员获取树时，其管理的子树内所有节点的 `MyIsAdmin` 均设为 `true`，使前端 `canManageNode` 计算对子节点也生效。

### 6.4 前端修复 (`OrgTreeNodeItem.vue`)

拖拽操作添加权限控制：`draggable` 属性绑定 `canManageNode`，非管理节点不可拖拽。

---

## 7. 总结

**核心问题**: 所有 org-tree API 路由被 `RequireSuperAdmin()` 中间件保护，导致组织管理员完全无法访问。虽然 Handler 层和 Service 层已具备组织管理员的权限判断逻辑，但请求根本到达不了这些代码。

**解决方案**: 将 org-tree 路由移至认证路由组，在 Handler 层实现细粒度权限控制，确保组织管理员仅可操作自己管辖的子树。同时修复 Service 层子节点管理标记传播和前端拖拽权限问题。
